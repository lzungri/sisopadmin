package ar.com.grupo306.sisopadmin.persistence.impl.common.populator.domain;

import java.util.Date;
import java.util.HashMap;

import ar.com.grupo306.sisopadmin.domain.modelo.impl.mensajes.Mensaje;
import ar.com.grupo306.sisopadmin.domain.modelo.impl.usuarios.Usuario;
import ar.com.grupo306.sisopadmin.persistence.impl.common.populator.TablePopulator;
import ar.com.grupo306.sisopadmin.service.provider.SisopAdminServiceProvider;

/**
 * @author Pablo
 */
public class MensajeTablePopulator extends TablePopulator {
	
	public void populateConversacion1() {
		Usuario grupo1 = findUsuario("grupo1");
		Usuario pablo = findUsuario("pablo");
		String contenidoMensaje1 = "Hola Pablo,<br />No entendemos demasiado de <b>threads </b>en Linux. Quisieramos saber si nos podr&iacute;as recomendar alg&uacute;n tipo de bibligraf&iacute;a para usar de base.<br />Saludos,<br /><br /><i>Grupo 1</i><br />";
		Mensaje primerMensaje = createMensaje(new Date(System.currentTimeMillis()), "Threads", contenidoMensaje1, grupo1, pablo, null, true);				
		String contenidoMensaje2 = "Estas webs son bastante claras en el tema de threads:<br /><ul><li>http://pauillac.inria.fr/~xleroy/linuxthreads/</li><li>http://linas.org/linux/threads-faq.html</li><li>http://evanjones.ca/software/threading.html</li></ul>Miren que est&aacute;n en <b><font color=\"#ff0000\">ingles</font></b><font color=\"#000000\">. En espa&ntilde;ol puede servirles esta: http://www.chuidiang.com/clinux/procesos/procesoshilos.php<br />Saludos,<br /><br />Pablo<br /></font>"; 
		Mensaje segundoMensaje = createMensaje(new Date(System.currentTimeMillis()), "Threads", contenidoMensaje2, pablo, grupo1, primerMensaje, true); 		
		String contenidoMensaje3 = "Much&iacute;simas gracias Pablo!<br />";
		Mensaje tercerMensaje = createMensaje(new Date(System.currentTimeMillis()), "Threads", contenidoMensaje3, grupo1, pablo, segundoMensaje, false);
		save(primerMensaje);
		save(segundoMensaje);
		save(tercerMensaje);				
	}
	
	public void populateConversacion2() {
		Usuario grupo1 = findUsuario("grupo1");
		Usuario pablo = findUsuario("pablo");
		String contenidoMensaje1 = "Hola Pablo,<br />Nos surgieron varias dudas con el ejercicio de la cola din&aacute;mica...<br />C&oacute;mo pens&aacute;s que deber&iacute;amos encararlo?<br />Gracias y saludos.<br />";
		Mensaje primerMensaje = createMensaje(new Date(System.currentTimeMillis()), "Cola dinámica", contenidoMensaje1, grupo1, pablo, null, true);				
		String contenidoMensaje2 = "<p>Les paso un poco de una web que encontr&eacute; hace un tiempo (la p&aacute;gina ya no est&aacute; activa):<br /></p><h1><a name=\"SECTION001000000000000000000\"> Asignaci&oacute;n din&aacute;mica de memoria y Estructuras din&aacute;micas</a></h1><p>La asignaci&oacute;n din&aacute;mica de memoria es una caracter&iacute;stica de C. Lepermite al usuario crear tipos de datos y estructuras de cualquiertama&ntilde;o de acuerdo a las necesidades que se tengan en el programa.</p><p>Se revisar&aacute;n dos de las aplicaciones m&aacute;s comunes:</p><ul><li>Arreglos din&aacute;micos</li><li>Estructuras din&aacute;micas de datos.</li></ul><p></p><h1><a name=\"SECTION001010000000000000000\">Uso de <tt>malloc, sizeof</tt> y <tt>free</tt> </a></h1><p>La funci&oacute;n <code>malloc</code> es empleada com&uacute;nmente para intentar ``tomar'' una porci&oacute;n contigua de memoria. Esta definida como:</p><pre>    void *malloc(size_t size);<br /></pre><p>Lo anterior indica que regresar&aacute; un apuntador del tipo <code>void *</code>, el cual es el inicio en memoria de la porci&oacute;n reservada de tama&ntilde;o <code>size</code>. Si no puede reservar esa cantidad de memoria la funci&oacute;n regresa un apuntador nulo o <code>NULL</code></p><p>Dado que <code>void *</code> es regresado, C asume que el apuntador puede ser convertido a cualquier tipo. El tipo de argumento <code>size_t</code> esta definido en la cabecera <code>stddef.h</code> y es un tipo entero sin signo.</p><p>Por lo tanto:</p><pre>char *cp;<br /><br />cp = (char *) malloc(100);<br /></pre><p>intenta obtener 100 bytes y asignarlos a la direcci&oacute;n de inicio a <code>cp</code>.</p><p>Es usual usar la funci&oacute;n <code>sizeof()</code> para indicar el n&uacute;mero de bytes, por ejemplo:</p><pre>int *ip;<br /><br />ip = (int *) malloc(100 * sizeof(int) );<br /></pre><p>El compilador de C requiere hacer una conversi&oacute;n del tipo. La forma de lograr la coerci&oacute;n (cast) es usando <code>(char *)</code> y <code>(int *)</code>, que permite convertir un apuntador <code>void</code>a un apuntador tipo char e int respectivamente. Hacer la conversi&oacute;n al tipo de apuntador correcto asegura que la aritm&eacute;tica con el apuntador funcionar&aacute; de forma correcta.</p> " +
				"<p>Es una buena pr&aacute;ctica usar <code>sizeof()</code> a&uacute;n si se conoce el tama&ntilde;o actual del dato que se requiere, -- ya que de esta forma el c&oacute;digo se hace independiente del dispositivo (portabilidad).</p><p>La funci&oacute;n <code>sizeof()</code> puede ser usada para encontrar el tama&ntilde;o de cualquier tipo de dato, variable o estructura. Simplemente se debe proporcionar uno de los anteriores como argumento a la funci&oacute;n.</p><p>Por lo tanto: </p><pre>int i;<br />struct COORD {float x,y,z};<br />struct COORD *pt;<br /><br />sizeof(int), sizeof(i), sizeof(struct COORD) y<br />sizeof(PT) son tambien sentencias correctas.<br /></pre><p>En el siguiente ejemplo se reserva memoria para la variable <code>ip</code>, en donde se emplea la relaci&oacute;n que existe entre apuntadores y arreglos, para manejar la memoria reservada como un arreglo. Por ejemplo, se pueden hacer cosas como: </p> <pre>main()<br />{<br />    int *ip, i;<br /><br />    ip = (int *) malloc(100 * sizeof(int) );<br /><br />    ip[0] = 1000;<br /><br />	 for (i=0; i&lt;100; ++i) <br />        scanf(\"%d\",ip++);<br /><br />}<br /></pre> <p>Cuando se ha terminado de usar una porci&oacute;n de memoria siempre se deber&aacute; liberar usando la funci&oacute;n <code>free()</code>. Esta funci&oacute;n permite que la memoria liberada este disponible nuevemente quiz&aacute;s para otra llamada de la funci&oacute;n <code>malloc()</code></p><p>La funci&oacute;n <code>free()</code> toma un apuntador como un argumento y libera la memoria a la cual el apuntador hace referencia.</p><p></p><h1><a name=\"SECTION001020000000000000000\"><tt>calloc</tt> y <tt>realloc</tt> </a></h1><p>Existen dos funciones adicionales para reservar memoria, <code>calloc()</code> y <code>realloc()</code>. Los prototipos son dados a continuaci&oacute;n: </p><pre>void *calloc(size_t nmemb, size_t size);<br /><br />void *realloc(void *ptr, size_t size);<br /></pre><p>Cuando se usa la funci&oacute;n <code>malloc()</code> la memoria no es inicializada (a <i>cero</i>) o borrada. Si se quiere inicializar la memoria entonces se puede usar la funci&oacute;n <code>calloc</code>. La funci&oacute;n <code>calloc</code> es computacionalmente un poco m&aacute;s cara pero, ocasionalmente, m&aacute;s conveniente que <code>malloc</code>. Se debe observar tambi&eacute;n la diferencia de sintaxis entre <code>calloc</code> y <code>malloc</code>, ya que <code>calloc</code> toma el n&uacute;mero de elementos deseados (<code>nmemb</code>) y el tama&ntilde;o del elemento (<code>size</code>), como dos argumentos individuales.</p><p>Por lo tanto para asignar a 100 elementos enteros que est&eacute;n inicializados a cero se puede hacer:" +
				"</p><pre>int *ip;<br /><br />ip = (int *) calloc(100, sizeof(int) );<br /></pre><p>La funci&oacute;n <code>realloc</code> intenta cambiar el tama&ntilde;o de un bloque de memoria previamente asignado. El nuevo tama&ntilde;o puede ser m&aacute;s grande o m&aacute;s peque&ntilde;o. Si el bloque se hace m&aacute;s grande, entonces el contenido anterior permanece sin cambios y la memoria es agregada al final del bloque. Si el tama&ntilde;o se hace m&aacute;s peque&ntilde;o entonces el contenido sobrante permanece sin cambios. </p><p>Si el tama&ntilde;o del bloque original no puede ser redimensionado, entonces <code>realloc</code>intentar&aacute; asignar un nuevo bloque de memoria y copiar&aacute; el contenido anterior. Por lo tanto, la funci&oacute;n devolver&aacute; un nuevo apuntador (o de valor diferente al anterior), este nuevo valor ser&aacute; el que deber&aacute; usarse. Si no puede ser reasignada nueva memoria la funci&oacute;n <code>realloc</code> devuelve <code>NULL</code>.</p><p>Si para el ejemplo anterior, se quiere reasignar la memoria a 50 enteros en vez de 100 apuntados por <code>ip</code>, se har&aacute;;</p><pre>ip = (int *) realloc ( ip, 50*sizeof(int) );<br /></pre><p></p><h1><a name=\"SECTION001030000000000000000\">Listas ligadas</a></h1><p>Regresando al ejemplo del cap&iacute;tulo anterior se defini&oacute; la estructura: </p><pre>typedef struct {<br />    int valor;<br />    struct ELEMENTO *sig;<br />} ELEMENTO;<br /></pre><p>La cual puede crecer en forma din&aacute;mica.</p><pre>ELEMENTO *liga;<br /><br />liga = (ELEMENTO *) malloc( sizeof(ELEMENT) );  /* Asigna memoria para liga */<br /><br />free(liga);    /* libera la memoria asignada al apuntador liga usando free() */<br /></pre><p></p><h1><a name=\"SECTION001040000000000000000\">Programa de revisi&oacute;n</a></h1><p><i>cola</i> es una colecci&oacute;n de ordenada de elementos de la que se pueden borrar elementos en un extremo (llamado el <i>frente</i> de la cola) o insertarlos en el otro (llamado el <i>final</i> de la cola.</p><p>Se muestra a continuaci&oacute;n el c&oacute;digo completo para manipular esta estructura:\";</p><pre>/* cola.c                                                   */<br />/* Demo de estructuras dinamicas en C                       */<br /><br />#include &lt;stdio.h&gt;<br /><br />#define FALSO 0<br /><br />typedef struct nodo {<br />    int     dato;<br />    struct nodo *liga;<br />} elemento_lista;<br /><br />void Menu (int *opcion);<br />elemento_lista * AgregaDato (elemento_lista * apuntlista, int dato);<br />elemento_lista * BorrarDato (elemento_lista * apuntlista);<br />void ImprCola (elemento_lista * apuntlista);<br />void LimpCola (elemento_lista * apuntlista);<br /><br />main () <br />{<br />    elemento_lista listmember, *apuntlista;<br />    int            dato, opcion;<br /><br />    apuntlista = NULL;<br />    do {<br />        Menu (&amp;opcion);<br />        switch (opcion) {<br />            case 1: <br />                printf (\"Ingresa un dato que sera agregado  \");<br />                scanf (\"%d\", &amp;dato);<br />                apuntlista = AgregaDato (apuntlista, dato);<br />                break;<br />            case 2: <br />                if (apuntlista == NULL)<br />                    printf (\"&iexcl;Cola vacia!\n\");<br />                else<br />                    apuntlista = BorrarDato (apuntlista);<br />                break;<br />            case 3: <br />                ImprCola (apuntlista);<br />                    break;<br /><br />            case 4: <br />                break;<br /><br />            default: <br />                printf (\"Opcion no valida - intentar nuevamente\n\");<br />                break;<br />        }<br />    } while (opcion != 4);<br />    LimpCola (apuntlista);<br />}                               /* fin de main */<br /><br /><br />void Menu (int *opcion)<br />{<br /><br />    char    local;<br /><br />    printf(\"\nEntre\t1 para agregar un dato,\n\t2 para borrar un dato,\n\t3 para mostrar el contenido de la cola\n\t4 para salir\n\");<br />    do {<br />        local = getchar ();<br />        if ((isdigit (local) == FALSO) &amp;&amp; (local != '\n')) <br />        {<br />            printf (\"\nSe debe ingresar un entero.\n\");<br />            printf (\"Teclee 1 para agregar, 2 para borrar, 3 para imprimir, 4 para salir\n\");<br />        }<br />    } while (isdigit ((unsigned char) local) == FALSO);<br />	*opcion = (int) local - '0';<br />}<br /><br /><br />elemento_lista *AgregaDato (elemento_lista *apuntlista, int dato) <br />{<br />    elemento_lista * lp = apuntlista;<br /><br />    if (apuntlista != NULL) {<br />        while (apuntlista -&gt; liga != NULL)<br />            apuntlista = apuntlista -&gt; liga;<br />        apuntlista -&gt; liga = (struct nodo *) malloc (sizeof (elemento_lista));<br />        apuntlista =  apuntlista -&gt; liga;<br />        apuntlista -&gt; liga = NULL;<br />        apuntlista -&gt; dato = dato;<br />        return lp;<br />    }<br />    else <br />    {<br />        apuntlista =  (struct nodo *) malloc (sizeof (elemento_lista));<br />        apuntlista -&gt; liga = NULL;<br />        apuntlista -&gt; dato = dato;<br />        return apuntlista;<br />    }<br />}<br /><br />elemento_lista *BorrarDato (elemento_lista *apuntlista) <br />{<br />    elemento_lista *tempp;<br />    printf (\"El elemento borrado es %d\n\", apuntlista -&gt; dato);<br />    tempp =  apuntlista -&gt; liga;<br />    free (apuntlista);<br />    return tempp;<br />}<br /><br /><br />void ImprCola (elemento_lista *apuntlista) <br />{<br />    if (apuntlista == NULL)<br />        printf (\"La cola esta vacia !!\n\");<br />    else<br />        while (apuntlista != NULL) {<br />            printf (\"%d\t\", apuntlista -&gt; dato);<br />            apuntlista =  apuntlista -&gt; liga;<br />        }<br />    printf (\"\n\");<br />}<br /><br /><br />void LimpCola (elemento_lista *apuntlista) <br />{<br />    while (apuntlista != NULL) {<br />        apuntlista = BorrarDato (apuntlista);<br />    }<br />}<br /></pre>" +
				"<p></p><h1><a name=\"SECTION001050000000000000000\">Ejercicios</a></h1><p></p><ol><li>Escribir un programa que lea un n&uacute;mero, que indica cu&aacute;ntos n&uacute;meros enteros ser&aacute;n guardados en un arreglo, crear el arreglo para almacenar el tama&ntilde;o exacto de los datos y entonces leer los enteros que ser&aacute;n guardados en el arreglo.</li><li>Escribir un programa para ordenar una secuencia de n&uacute;meros usando un &aacute;rbol binario. Un &aacute;rbol binario es una estructura tipo &aacute;rbol con solamente 2 (posibles) ramas de cada nodo. Cada rama entonces representa una decisi&oacute;n de falso o verdadero. Para ordenar los n&uacute;meros simplemente asignar a la rama izquierda los n&uacute;meros menores respecto al n&uacute;mero del nodo, y en la rama derecha el resto (es decir, los que son mayores o iguales a).<p></p><div align=\"center\"><a name=\"fig:arbol\"></a><a name=\"1263\"></a></div></li></ol><table border=\"0\" width=\"100%\"></table>Para obtener una lista ordenada en forma ascendente, recorrer el &aacute;rbol en preorden (<i>depth-first order</i>), es decir, visitar la ra&iacute;z, recorrer el sub&aacute;rbol izquierdo en orden y recorrer el sub&aacute;rbol derecho en orden. Por lo que la salida deber&aacute; ser: <pre>Los valores ordenados son:<br />0 3  4  4  5  5  7  9  14 14 15 16 17 18 20<br /></pre><p>Mostrar 10 valores por l&iacute;nea.</p>";
		Mensaje segundoMensaje = createMensaje(new Date(System.currentTimeMillis()), "Cola dinámica", contenidoMensaje2, pablo, grupo1, primerMensaje, true); 		
		String contenidoMensaje3 = "Nos quedo mucho más claro, gracias Pablo.";
		Mensaje tercerMensaje = createMensaje(new Date(System.currentTimeMillis()), "Cola dinámica", contenidoMensaje3, grupo1, pablo, segundoMensaje, false);
		save(primerMensaje);
		save(segundoMensaje);
		save(tercerMensaje);				
	}

	private Usuario findUsuario(String loginName) {
		HashMap map = new HashMap();
		map.put("loginName", loginName); 
		return (Usuario) SisopAdminServiceProvider.getPersistenceService().findByFiltro(Usuario.class, map).iterator().next();
	}
	
	private Mensaje createMensaje(Date fechaAlta, String titulo, String contenido, Usuario emisor, Usuario receptor, Mensaje mensajePadre, Boolean leidoPorReceptor){
		Mensaje mensaje = new Mensaje();
		mensaje.setFechaAlta(fechaAlta);
		mensaje.setTitulo(titulo);
		mensaje.setContenido(contenido);
		mensaje.setEmisor(emisor);
		mensaje.setReceptor(receptor);		
		mensaje.setMensajePadre(mensajePadre);
		mensaje.setLeidoPorReceptor(leidoPorReceptor);
		return mensaje;
	}
	
}